{"data":{"markdownRemark":{"html":"<h3>Reachability</h3>\n<p>Simply put, “reachable” values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.</p>\n<ul>\n<li>Local variables and parameters of the current function</li>\n<li>Variables and parameters for other functions on the current chain of nested calls</li>\n<li>Global variables</li>\n<li>Any other value is considered reachable if it’s reachable from a root by a reference or by a chain of references</li>\n</ul>\n<p>There’s a background process in the JavaScript engine that is called garbage collector. It monitors all objects and removes those that have become unreachable.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// user has a reference to the object</span>\n<span class=\"token keyword\">let</span> user <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"John\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Here the arrow depicts an object reference. The global variable \"user\" references the object <code class=\"language-text\">{name: &quot;John&quot;}</code> (we’ll call it John for brevity). The \"name\" property of John stores a primitive, so it’s painted inside the object.</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/memory-user-john.png\" alt=\"image.png\"></p>\n<p>If the value of user is overwritten, the reference is lost:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">user <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now John becomes unreachable. There’s no way to access it, no references to it. Garbage collector will junk the data and free the memory.</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/memory-user-john-lost.png\" alt=\"image.png\"></p>\n<h4>Two references</h4>\n<p>Now let’s imagine we copied the reference from user to admin</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// user has a reference to the object</span>\n<span class=\"token keyword\">let</span> user <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"John\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> admin <span class=\"token operator\">=</span> user<span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://javascript.info/article/garbage-collection/memory-user-john-admin.png\" alt=\"image.png\"></p>\n<p>Now if we do the same:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">user <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Then the object is still reachable via admin global variable, so it’s in memory. If we overwrite admin too, then it can be removed.</p>\n<h4>Interlinked objects</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">marry</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">man<span class=\"token punctuation\">,</span> woman</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  woman<span class=\"token punctuation\">.</span>husband <span class=\"token operator\">=</span> man<span class=\"token punctuation\">;</span>\n  man<span class=\"token punctuation\">.</span>wife <span class=\"token operator\">=</span> woman<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    father<span class=\"token punctuation\">:</span> man<span class=\"token punctuation\">,</span>\n    mother<span class=\"token punctuation\">:</span> woman\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> family <span class=\"token operator\">=</span> <span class=\"token function\">marry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"John\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Ann\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The resulting memory structure:</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/family.png\" alt=\"image.png\"></p>\n<p>Now let’s remove two references:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">delete</span> family<span class=\"token punctuation\">.</span>father<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">delete</span> family<span class=\"token punctuation\">.</span>mother<span class=\"token punctuation\">.</span>husband<span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://javascript.info/article/garbage-collection/family-delete-refs.png\" alt=\"image.png\"></p>\n<p>We can see that John has no incoming reference any more, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.\nAfter garbage collection:</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/family-no-father-2.png\" alt=\"image.png\"></p>\n<h4>Unreachable island</h4>\n<p>It is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">family <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The former \"family\" object has been unlinked from the root, there’s no reference to it any more, so the whole island becomes unreachable and will be removed.\nThe in-memory picture becomes:</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/family-no-family.png\" alt=\"image.png\"></p>\n<h3>Algorithms</h3>\n<p>The basic garbage collection algorithm is called “mark-and-sweep”.</p>\n<ol>\n<li>The garbage collector takes roots and “marks” (remembers) them.</li>\n<li>Then it visits and “marks” all references from them.</li>\n<li>Then it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future.</li>\n<li>And so on until there are unvisited references.</li>\n<li>All objects except marked ones are removed.</li>\n</ol>\n<p>For instance, let our object structure look like this:</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/garbage-collection-1.png\" alt=\"image.png\"></p>\n<p>We can clearly see an “unreachable island” to the right side</p>\n<h4>mark-and-sweep</h4>\n<p>The first step marks the roots:</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/garbage-collection-2.png\" alt=\"image.png\"></p>\n<p>Then their references are marked:</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/garbage-collection-3.png\" alt=\"image.png\"></p>\n<p>…And their references, while possible:</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/garbage-collection-4.png\" alt=\"image.png\"></p>\n<p>Now the objects that could not be visited in the process are considered unreachable and will be removed:</p>\n<p><img src=\"https://javascript.info/article/garbage-collection/garbage-collection-5.png\" alt=\"image.png\"></p>\n<h3>Optimizations</h3>\n<p>JavaScript engines apply many optimizations to make it run faster and not affect the execution.</p>\n<h4>Generational collection</h4>\n<p>objects are split into two sets: “new ones” and “old ones”. Many objects appear, do their job and die fast, they can be cleaned up aggressively. Those that survive for long enough, become “old” and are examined less often.</p>\n<h4>Incremental collection</h4>\n<p>if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine tries to split the garbage collection into pieces. Then the pieces are executed one by one</p>\n<h4>Idle-time collection</h4>\n<p>the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution</p>\n<h3>Summary</h3>\n<ul>\n<li>Garbage collection is performed automatically. We cannot force or prevent it.</li>\n<li>Objects are retained in memory while they are reachable.</li>\n<li>Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole.</li>\n</ul>\n<h2>Trash talk: the Orinoco garbage collector</h2>\n<h3>Major GC (Full Mark-Compact)</h3>\n<p><img src=\"https://v8.dev/_img/trash-talk/01.svg\" alt=\"image.png\"></p>\n<h4>Marking</h4>\n<p>Figuring out which objects can be collected is an essential part of garbage collection. Garbage collectors do this by using reachability as a proxy for ‘liveness’. This means that any object currently reachable within the runtime must be kept, and any unreachable objects may be collected.</p>\n<h4>Sweeping</h4>\n<p>Sweeping is a process where gaps in memory left by dead objects are added to a data structure called a <strong>free-list</strong>. Once marking has completed, the GC finds contiguous gaps left by unreachable objects and adds them to the appropriate free-list. Free-lists are separated by the size of the memory chunk for quick lookup. In the future when we want to allocate memory, we just look at the free-list and find an appropriately sized chunk of memory.</p>\n<h4>Compaction</h4>\n<p>The major GC also chooses to evacuate/compact some pages, based on a fragmentation heuristic. You can think of compaction sort of like hard-disk defragmentation on an old PC.\n磁盘压缩</p>\n<h3>Generational</h3>\n<p>The heap in V8 is split into different regions called generations. There is a young generation (split further into ‘nursery’ and ‘intermediate’ sub-generations), and an old generation. Objects are first allocated into the nursery. If they survive the next GC, they remain in the young generation but are considered ‘intermediate’. If they survive yet another GC, they are moved into the old generation.</p>\n<p><img src=\"https://v8.dev/_img/trash-talk/02.svg\" alt=\"image.png\"></p>\n<p>In garbage collection there is an important term: “The Generational Hypothesis”. This basically states that most objects die young. In other words, most objects are allocated and then almost immediately become unreachable, from the perspective of the GC. This holds not only for V8 or JavaScript, but for most dynamic languages.</p>\n<p>This means that we only pay a cost (for copying) proportional to the number of surviving objects, not the number of allocations.</p>\n<h3>Minor GC</h3>\n<p>There are two garbage collectors in V8. The Major GC (Mark-Compact) collects garbage from the whole heap. The Minor GC (Scavenger) collects garbage in the young generation.</p>\n<p>In the Scavenger, which only collects within the young generation, surviving objects are always evacuated to a new page.V8 uses a ‘semi-space’ design for the young generation. This means that half of the total space is always empty, to allow for this evacuation step.</p>\n<p>During a scavenge, this initially-empty area is called ‘To-Space’. The area we copy from is called ‘From-Space’.</p>\n<p>The evacuation step moves all surviving objects to a contiguous chunk of memory (within a page). This has the advantage of completing removing fragmentation - gaps left by dead objects. We then switch around the two spaces i.e. To-Space becomes From-Space and vice-versa. Once GC is completed, new allocations happen at the next free address in the From-Space.</p>\n<p><img src=\"https://v8.dev/_img/trash-talk/03.svg\" alt=\"image.png\"></p>\n<p>We quickly run out of space in the young generation with this strategy alone. Objects that survive a second GC are evacuated into the old generation, rather than To-Space.</p>\n<p>The final step of scavenging is to update the pointers that reference the original objects, which have been moved. Every copied object leaves a forwarding-address which is used to update the original pointer to point to the new location.</p>\n<p><img src=\"https://v8.dev/_img/trash-talk/04.svg\" alt=\"image.png\"></p>\n<p>In scavenging we actually do these three steps — <strong>marking, evacuating, and pointer-updating</strong>.</p>\n<h3>Orinoco</h3>\n<p>Orinoco is the codename of the GC project to make use of the latest and greatest parallel, incremental and concurrent techniques for garbage collection.</p>\n<h4>Parallel</h4>\n<p>This is still a ‘stop-the-world’ approach, but the total pause time is now divided by the number of threads participating</p>\n<p><img src=\"https://v8.dev/_img/trash-talk/05.svg\" alt=\"image.png\"></p>\n<h4>Incremental</h4>\n<p>Incremental is where the main thread does a small amount of work intermittently. We don’t do an entire GC in an incremental pause, just a small slice of the total work required for the GC.\nThis does not reduce the amount of time spent on the main thread (in fact, it usually increases it slightly), it just spreads it out over time.</p>\n<p><img src=\"https://v8.dev/_img/trash-talk/06.svg\" alt=\"image.png\"></p>\n<h4>Concurrent</h4>\n<p>Concurrent is when the main thread executes JavaScript constantly, and helper threads do GC work totally in the background. This is the most difficult of the three techniques: anything on the JavaScript heap can change at any time\nThe advantage here is that the main thread is totally free to execute JavaScript</p>\n<p><img src=\"https://v8.dev/_img/trash-talk/07.svg\" alt=\"image.png\"></p>\n<h3>State of GC in V8</h3>\n<h4>Scavenging</h4>\n<p>V8 uses parallel scavenging to distribute work across helper threads during the young generation GC.</p>\n<p><img src=\"https://v8.dev/_img/trash-talk/08.svg\" alt=\"image.png\"></p>\n<h4>Major GC</h4>\n<p>Major GC in V8 starts with concurrent marking.\nConcurrent marking happens entirely in the background while JavaScript is executing on the main thread</p>\n<p>When the concurrent marking is finished, The main thread pause begins during this phase. This represents the total pause time of the major GC. The main thread scans the roots once again, to ensure that all live objects are marked,\nand then along with a number of helpers, starts parallel compaction and pointer updating.</p>\n<p><img src=\"https://v8.dev/_img/trash-talk/09.svg\" alt=\"image.png\"></p>\n<h4>Idle-time GC</h4>\n<p>The GC can post ‘Idle Tasks’ which are optional work that would eventually be triggered anyway. Embedders like Chrome might have some notion of free or idle time. For example in Chrome, at 60 frames per second, the browser has approximately 16.6 ms to render each frame of an animation</p>\n<p><img src=\"https://v8.dev/_img/trash-talk/10.svg\" alt=\"image.png\"></p>\n<p>The parallel Scavenger has reduced the main thread young generation garbage collection total time by about 20%–50%, depending on the workload. Idle-time GC can reduce Gmail’s JavaScript heap memory by 45% when it is idle. Concurrent marking and sweeping has reduced pause times in heavy WebGL games by up to 50%.</p>\n<ul>\n<li><a href=\"https://queue.acm.org/detail.cfm?id=2977741\">https://queue.acm.org/detail.cfm?id=2977741</a></li>\n<li><a href=\"https://v8.dev/blog/free-garbage-collection\">https://v8.dev/blog/free-garbage-collection</a></li>\n<li><a href=\"https://v8.dev/blog/jank-busters\">https://v8.dev/blog/jank-busters</a></li>\n<li><a href=\"https://v8.dev/blog/orinoco\">https://v8.dev/blog/orinoco</a></li>\n</ul>","frontmatter":{"date":"March 01, 2019","path":"garbage-collection","category":"frontend","title":"Garbage Collection"}}},"pageContext":{"location":"garbage-collection","category":"frontend"}}